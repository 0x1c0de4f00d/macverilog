
WHAT IS XNF

XNF is the Xilinx Netlist Format. This is somewhat specific to the
Xilinx tool chain, but it is sufficiently ubiquitous that it's still
worth it. This format can be fed to place and route tools and
simulators. Since some third party simulators accept XNF, the format
may be useful even independent of Xilinx parts.

Icarus Verilog supports XNF as specified by the Xilinx Netlist Format
Specification, Version 6.1.

IVL SUPPORT FOR XNF

Icarus Verilog has a code generator and synthesis functions that
support generation of XNF netlists. The XNF modules also allow the
programmer to use $attributes to control certain aspects of code
generation.

XNF code generation is enabled with the ``-t xnf'' flag on the command
line. The code generator needs to know the type of part to generate
code for, so the ``-fpart=<type>'' flag is also needed. For example,
to generate code for the 4010E the command line might start out as:

	 ivl -txnf -fpart=4010e -Fxnfsyn -Fsigfold -Fxnfio [...]

Icarus Verilog includes the functions ``xnfsyn'' and ``xnfio'' to
perform transformations and optimizations on the design before code is
generated. The xnfsyn function matches certain behavioral constructs
to XNF components, and the xnfio function generates pads and fills the
IOBs.

XNFSYN FUNCTION

This function does synthesis transformations on the entered design,
making it possible to generate XNF netlist components from certain
behavioral constructs. This is needed in Verilog for example to model
some of the synchronous components of the XNF library.

It is a bit much to expect a Verilog compiler in general to generate
components from arbitrary behavioral descriptions, so the xnfsyn
function works by matching statements that have some documented
structure, and substituting them for the equivalent XNF component. A
fully synthesize-able design, then, is one where the behavioral
statements can all be matched and substituted by the xnfsyn function.

XNFIO FUNCTION

The "xnfio" function transforms the netlist where the IOBs are
concerned. The signals with PAD attributes are checked, and
surrounding circuitry generated to conform to the logic available in
the IOB.

If the pad is an OPAD, the function will look for an existing buf or
not gate connected to the PAD signal. If the gate is appropriately
connected, the buf or not gate will be turned into an OBUF. This pulls
the buf or inverter into the IOB, freeing a CLB and providing the
required pin circuitry.

If the pad is an IPAD, the function will look for a buf, and convert
that to an IBUF. Since Xilinx IOBs cannot invert the output from an
IBUF, NOT gates cannot be absorbed as in the OPAD case.


/*
 * Copyright (c) 1998-1999 Stephen Williams (steve@icarus.com)
 *
 *    This source code is free software; you can redistribute it
 *    and/or modify it in source code form under the terms of the GNU
 *    General Public License as published by the Free Software
 *    Foundation; either version 2 of the License, or (at your option)
 *    any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 */


 $Log: xnf.txt,v $
 Revision 1.4  1999/08/14 22:48:21  steve
  Mention the sigfold function.

 Revision 1.3  1999/07/22 02:05:20  steve
  is_constant method for PEConcat.

 Revision 1.2  1999/07/18 21:17:51  steve
  Add support for CE input to XNF DFF, and do
  complete cleanup of replaced design nodes.

 Revision 1.1  1999/05/01 02:57:11  steve
  XNF target documentation.

